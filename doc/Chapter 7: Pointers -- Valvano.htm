<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="generator" content="Microsoft FrontPage 6.0">
  <title>Chapter 7: Pointers -- Valvano</title>
  <meta name="Template" content="Power HD:Applications:Microsoft Office 98:Templates:Web Pages:Blank Web Page">
<style type="text/css">/**
 * Highlight style classes
 * .a background color
 * .b underline
 * .c underline + font color
 */
 
@media screen{
em.diigoHighlight {
	text-align:inherit;
	text-decoration: inherit;
	line-height:inherit;
	font:inherit;
	color:inherit;
	display:inline;
	position:relative;
}
em.diigoHighlight.a_style.mouseOvered {
	background-color: #ffc62a !important;
}	

em.diigoHighlight.b_style.mouseOvered, em.diigoHighlight.c_style.mouseOvered {
	border-bottom: solid 2px #ffc62a;
}
	
em.diigoHighlight.c_style {
	color: #000099;
}
em.diigoHighlight.c_style.mouseOvered {
	color: #ffc62a;
}	

em.diigoHighlight.a_style.yellow {
	background-color: #FF9;
}

em.diigoHighlight.b_style.yellow, em.diigoHighlight.c_style.yellow {
	border-bottom: solid 2px #FF9;
}
	
img.diigoHighlight.yellow {/*image highlight*/
	cursor: pointer; 
	outline:2px solid #FF9;
}
	
em.diigoHighlight.a_style.blue {
	background-color: #ABD5FF;
}

em.diigoHighlight.b_style.blue, em.diigoHighlight.c_style.blue {
	border-bottom: solid 2px #ABD5FF;
}
	
img.diigoHighlight.blue {/*image highlight*/
	cursor: pointer; 
	outline:2px solid #ABD5FF;
}
	
	
em.diigoHighlight.a_style.green {
	background-color: #B2E57E;
}

em.diigoHighlight.b_style.green, em.diigoHighlight.c_style.green {
	border-bottom: solid 2px #B2E57E;
}

img.diigoHighlight.green {/*image highlight*/
	cursor: pointer; 
	outline:2px solid #B2E57E;
}	
	
	
em.diigoHighlight.a_style.pink {
	background-color: #ffcccc;
}

em.diigoHighlight.b_style.pink, em.diigoHighlight.c_style.pink {
	border-bottom: solid 2px #ffcccc;
}
	
img.diigoHighlight.pink {/*image highlight*/
	cursor: pointer; 
	outline:2px solid #ffcccc;
}	
	
img.diigoHighlight.mouseOvered {
	cursor: pointer; 
	outline:2px solid #ffc62a;
}	
	

div.diigotb-inline-cloud{
	position:fixed !important;
	width:440px !important;
	height:370px !important;
	left:0;top:0;
	background-color:#fef5c7 !important;
	z-index:9999999999 !important;
	display:none;
	-moz-border-radius:15px !important;
}
/*  capture image */

.diigotb-body #diigotb-upload-cover{
	cursor:crosshair!important;
	z-index:1999999!important;
	position:fixed!important;
	left:0!important;
	top:31px;
}
	
.diigotb-body #diigotb-upload-tip{
    color: #fff!important;
    padding:2px 4px!important;
    position:fixed!important;
    z-index:11000001!important;
}
	
.diigotb-body #diigotb-upload-select{
	position:fixed!important;
	z-index:1000001;
}
	
.diigotb-body #diigotb-upload-resizer{
	z-index:11000002!important;
	position:fixed!important;
	cursor:move!important;
	border:1px dashed black!important;
}
	
.diigotb-body #currentColor{
  background-color: #fff!important;
  width: 37px!important;
  height: 37px!important;
  padding: 1px!important;
  border: 1px solid #2e68e6!important;
  float: left!important;
  margin: 0 5px 0 0!important;
}
	
.diigotb-body #currentColor div{
  width: 37px!important;
  height: 37px!important;	
  margin:0!important;
}
.diigotb-body .selectPanel{
	margin-top:5px!important;
}
	
.diigotb-body .colorCell{
  float: left!important;
  margin: 0 1px 1px 0!important;
  border: 1px solid #5f92ff!important;
  width: 18px!important;
  height: 18px!important;
}
	
.diigotb-body .colorCell:hover{
  border: 1px solid #FF9900!important;
}
.diigotb-body .colorCell.actived{
  border: 1px solid #FF9900!important;
}	
	
.diigotb-body .colorCell div{
  width: 18px!important;
  height: 18px!important;
  cursor:pointer!important;
  margin:0!important;
}

.diigotb-body .capture-black{background-color:#000!important;}
.diigotb-body .capture-white{background-color:#fff!important;}
.diigotb-body .capture-gray{background-color:#808080!important;}
.diigotb-body .capture-light-gray{background-color:#c0c0c0!important;}

.diigotb-body .capture-red{background-color:#ff0000!important;}
.diigotb-body .capture-cyan{background-color:#00ffff!important;}
.diigotb-body .capture-orange{background-color:#ff9900!important;}
.diigotb-body .capture-blue{background-color:#0000ff!important;}

.diigotb-body .capture-yellow{background-color:#ffff00!important;}
.diigotb-body .capture-purple{background-color:#9900ff!important;}
.diigotb-body .capture-green{background-color:#00ff00!important;}
.diigotb-body .capture-pink{background-color:#ff00ff!important;}
	
.diigotb-body #diigotb-colorpanel{
	background:transparent url(chrome://diigotb/skin/ann-bar-palette-bg-left.png) no-repeat scroll left center!important;
	display:block;
	height:55px!important;
	position:fixed!important;
	width:180px!important;
	z-index:11000022!important;
	margin:0!important;
}
	
.diigotb-body .diigotb-cbg{
	background:transparent url(chrome://diigotb/skin/ann-bar-palette-bg-right.png) no-repeat scroll right top!important;
	height:55px!important;
	line-height:55px!important;
	padding-left:6px!important;
	width:180px!important;
	margin:0!important;
}

	
.diigotb-body #currentArrow{
	background:transparent url(chrome://diigotb/skin/ann-bar-palette-arrow.png) no-repeat scroll 0 0!important;
	height:6px!important;
	left:0;
	position:relative!important;
	top:-5px;
	width:7px!important;
	margin:0!important;
}
	
.diigotb-body #currentArrow._istop{
	background:transparent url(chrome://diigotb/skin/ann-bar-palette-arrow-down.png) no-repeat scroll 0 0!important;
	top:51px!important;
}
	
	
.diigotb-body #diigotb-text-area{
	position:fixed!important;
	z-index:11000010!important;
}
	
.diigotb-body .diigotb-text-input{
	font: 18px/22px Helvetica,Arial,sans-serif!important;
	border:0px solid #5f92ff!important;
	z-index:11000011!important;
}	
	
.diigotb-body #diigotb-editpanel{
	background:transparent url(chrome://diigotb/skin/ann-bar-bg-right.png) no-repeat scroll right center!important;
	height:35px!important;
	position: fixed!important;
	z-index:11000022!important;
	margin:0!important;
}
	
	
.diigotb-body .diigotb-btn div{
	cursor:pointer!important;
	width:18px!important;
	height:18px!important;
	margin:2px!important;
}
.diigotb-body .diigotb-btn{
	width:23px!important;
	height:23px!important;
}
		
	
.diigotb-body #diigotb-editpanel .diigotb-bg{
	background:transparent url(chrome://diigotb/skin/ann-bar-bg-left.png) repeat-x scroll left center!important;
	height:35px!important;
	padding-left:6px!important;
	line-height:35px!important;
	margin:0!important;
}
	
		
.diigotb-body div.diigotb-tip{
	-moz-border-radius:4px 4px 4px 4px;
	background-color:#f1f2f7;
	border:1px solid #767676;
	color:black;
	display:none;
	-moz-box-shadow:5px 5px 5px -5px #767676;
	font:12px Arial,Helvetica,sans-serif;
	margin:0 !important;
	padding:3px 6px !important;
	position:absolute;
	z-index:2147483647;
}
	
.diigotb-body #diigotb-editpanel div.diigotb-btn{
	padding:0px!important;
	display:inline-table!important;
	margin-bottom:0 !important;
	margin-left:0 !important;
	margin-right:0 !important;
	margin-top:5px;
}
	
	
.diigotb-body #diigotb-editpanel div.diigotb-sep img{
	padding:0!important;
	margin:0!important;
}
	
.diigotb-body #diigotb-editpanel div.diigotb-sep{
	padding:4px 0!important;
	display:inline-table!important;
	margin:0!important;
	line-height:0 !important;
}	
	
.diigotb-body #diigotb-editpanel div.diigotb-btn.enabled:hover{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-current.png') no-repeat!important;
}
	
.diigotb-body #diigotb-editpanel #diigotb-undo.enabled div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-undo.png') no-repeat center center!important;
}
	
.diigotb-body #diigotb-editpanel div.diigotb-btn.actived{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-current.png') no-repeat!important;
}
	
.diigotb-image-border{
	border:1px solid #666 !important;
}
	
#diigotb-imagepanel{
	height:22px!important;
	position: absolute!important;
	z-index:11000022!important;
	margin:0!important;
}

#diigotb-imagepanel .diigotb-btn{
	cursor:pointer!important;
	width:20px!important;
	height:20px!important;
	margin:2px!important;
	float:left !important;
	background:transparent url(chrome://diigotb/skin/save-image-action-icons.png) no-repeat scroll!important;
}	
	
	
#diigotb-imagepanel #diigotb-quick-save{
	background-position:0 0!important;
}
		
#diigotb-imagepanel.processing #diigotb-quick-save{
	background-position:0 -20px!important;
	cursor:default!important;
}

		
#diigotb-imagepanel.needpremium #diigotb-quick-save{
	background-position:0 -20px!important;
	cursor:default!important;
}	

#diigotb-imagepanel.hassaved #diigotb-quick-save{
	background-position: -60px 0!important;
	cursor: pointer !important;
}

.diigotb-imagetip{
	background:transparent url(chrome://diigotb/skin/notice-bar-bg-right.png) no-repeat scroll right center !important;
	height:21px !important;
	margin:0 !important;
	position:absolute !important;
	z-index:11000022 !important;
	width:106px;
}
	
.diigotb-imagebg{
	background:transparent url(chrome://diigotb/skin/notice-bar-bg-left.png) repeat-x scroll left center !important;
	height:21px !important;
	margin:0 !important;
	padding-left:6px !important;
	width:90px;
}
	
.diigotb-imagetip-text{
	padding-left:20px!important;
	font:11px/13px Helvetica,Arial,sans-serif!important;
	color:white!important;
	line-height:20px!important;
	float:left;
}
	
.diigotb-imagetip.processing .diigotb-imagetip-text{
	background:transparent url(chrome://diigotb/skin/processing-fb.gif) no-repeat scroll left center !important;
}
	
.diigotb-imagetip.hassaved .diigotb-imagetip-text{
	background:transparent url(chrome://diigotb/skin/icon-done.png) no-repeat scroll left center !important;
}
	
.diigotb-border{
	position: absolute!important;
	z-index:11000000!important;
	margin:0!important;
	background-color: #4b8cdc!important;
}
.diigotb-left{
	width:1px!important;
}
.diigotb-right{
	width:1px!important;
}
.diigotb-top{
	height:1px!important;
}
.diigotb-bottom{
	height:1px!important;
}

.diigotb-body #diigotb-rect div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-rectangle.png') no-repeat center center!important;
}	
.diigotb-body #diigotb-round div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-ellipse.png') no-repeat center center!important;
}
.diigotb-body #diigotb-text div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-font.png') no-repeat center center!important;
}
	
.diigotb-body #diigotb-arrow div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-arrow.png') no-repeat center center!important;
}
	
.diigotb-body .diigotb-sep{
	background: transparent url('chrome://diigotb/skin/ann-bar-bg-separator.png') no-repeat center center!important;
}
	
.diigotb-body #diigotb-undo div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-undo-disabled.png') no-repeat center center!important;
}
	
.diigotb-body #diigotb-capture-save div{
	background: transparent url('chrome://diigotb/skin/ann-bar-opt-quickly-save.png') no-repeat center center!important;
}
	
	
	
.diigotb-body #diigotb-upload-resizer div {
  position: absolute!important;
  width: 9px!important;
  height: 9px!important;
  /*background-color: white;*/
  z-index:11000002!important;
  margin:0px!important;
  background:transparent url(chrome://diigotb/skin/spot.png) no-repeat scroll left center!important;
}

.diigotb-body #diigotb-upload-resizer div.gleft {
  left: -9px!important;
}

.diigotb-body #diigotb-upload-resizer div.gtop {
  top: -9px!important;
}

.diigotb-body #diigotb-upload-resizer div.gright {
  right: -9px!important;
}

.diigotb-body #diigotb-upload-resizer div.gbottom {
  bottom: -9px!important;
}

.diigotb-body #diigotb-upload-resizer div.ghor {
  margin-left: auto!important;
  margin-right: auto!important;
  left: 0px!important;
  right: 0px!important;
}

.diigotb-body #diigotb-upload-resizer div.gver {
  margin-top: auto!important;
  margin-bottom: auto!important;
  top: 0px!important;
  bottom: 0px!important;
}
	
.diigotb-body{
	padding-top: 31px!important;
}
	
.diigotb-body #diigotb-topbar{
  background: url(chrome://diigotb/skin/topbar-bg.png) left top repeat-x!important;
  border-bottom: 1px solid #999!important;
  color: #555!important;
  font: 12px/18px Helvetica,Arial,sans-serif!important;
  height: 30px!important;
  line-height: 30px!important;
  position: fixed!important;
  left: 0!important;
  top: 0!important;
  text-align:center!important;
  z-index:1999999!important;
}

.diigotb-body #diigotb-msg img{
  margin:0 5px 0 0!important;
  vertical-align: middle!important;
}
	
.diigotb-body #diigotb-msg{
	color:#333!important;
}

.diigotb-body #diigotb-msg a{
  color: #0044cc!important;
  text-decoration: none!important;
}

.diigotb-body #diigotb-msg a:hover{
  text-decoration: underline!important;
}

.diigotb-body #diigotb-escLink{
  display: block!important;
  float: right!important;
  margin: 5px 5px 0 0!important;
  text-decoration: none!important;
  width: 50px!important;
  cursor:pointer!important;
}

.diigotb-body #diigotb-escLink:hover{
  text-decoration: underline!important;
}

.diigotb-body #diigotb-escLink span{
  background: url(chrome://diigotb/skin/esc-right.png) right top no-repeat!important;
  display: block!important;
  padding-right: 9px!important;
}

.diigotb-body #diigotb-escLink span strong{
  background: url(chrome://diigotb/skin/esc-left.png) left top no-repeat!important;
  display: block!important;
  color: #fff!important;
  font-weight: 700!important;
  line-height: 20px!important;
  text-indent:7px!important;
}
	
	

/*highlight label*/
.diigoHighlight .diigoHighlightLabel sup {
	font:normal normal normal 8px/8px "lucida grande",tahoma,verdana,arial,sans-serif;
	text-decoration:none;
	background-color:inherit;
	cursor:default;
}
	
body.diigoHiPen.yellow{
	cursor:url(chrome://diigotb/skin/highlighter-orange.cur), text !important
}
	
body.diigoHiPen.blue{
	cursor:url(chrome://diigotb/skin/highlighter-blue.cur), text !important
}

body.diigoHiPen.green{
	cursor:url(chrome://diigotb/skin/highlighter-green.cur), text !important
}	
	
body.diigoHiPen.pink{
	cursor:url(chrome://diigotb/skin/highlighter-pink.cur), text !important
}
em.diigoHighlight.type_0.commented {	
	padding-left:30px;
}
	
/*float note*/
div.diigoHighlight.type_2 {
	position:absolute;
	width:29px;
	height:36px;
	text-align:center;
	background:transparent url('chrome://diigotb/skin/float_icon.png') no-repeat 50% 50%;
	z-index:9996;
}
div.diigoHighlight.type_2.mouseOvered {
	position:absolute;
	width:37px;
	height:31px;
	text-align:center;
	background:transparent url('chrome://diigotb/skin/float_icon.png') no-repeat;
	z-index:9996;
}	
div.diigoHighlight.type_2 span {
	color:#000;
	font:bold 13px Arial, Helvetica, sans-serif;
	cursor: default;
	line-height: 37px;
	text-shadow: #fff 0 1px 0;
}
	

div.diigoIcon.commented.TextIcon.diigoEdit{
	background-repeat:no-repeat !important;
	background-position:right !important;
}

	
div.diigoIcon.commented.ImageIcon.diigoEdit{
	background-repeat:no-repeat !important;
	background-position:right !important;
}


/*mouse over effect*/
/*
.diigoHighlight.id_190e5778b533dc0fa1b1660653a4f6f5 {outline: 2px dotted green !important;}
*/
div.diigoIcon{
	cursor:pointer !important;
	margin: 0pt; 
	padding: 0px 0px 0px 0px;
	position: absolute;
	display:none;
	width: 24px !important; 
	z-index:999999;
	height: 23px !important;
	background: transparent url('chrome://diigotb/skin/edit-highlight.png') no-repeat left;
}

div.diigoIcon span{
	color:#000000;
	display:block;
	font-family:Helvetica,Arial,sans-serif;
	font-size:13px;
	font-weight:700;
	line-height:18px;
	text-align:center;
	text-shadow:0 1px 1px #FFFFFF;
}

div.diigoIcon.commented.ImageIcon{
	display:block !important;
	background-color: transparent !important;
}
	
div.diigoIcon:hover{
	background-color: transparent !important;
	background-repeat:no-repeat !important;
	background-position:right !important;
}
	
div.diigoIcon.commented.TextIcon{
	display:block !important;
	left:0;
	bottom:0;
}
	
div.diigoIcon.commented.public{
	background: #FFFFFF url('chrome://diigotb/skin/public-annotation.png') no-repeat left;
}

div.diigoIcon.commented.private{
	background: #FFFFFF url('chrome://diigotb/skin/private-annotation.png') no-repeat left;
}
	
div.diigoIcon.commented.group{
	background: #FFFFFF url('chrome://diigotb/skin/group-annotation.png') no-repeat left;
}
	
/*Clip video*/
div.diigoClipVideo{
	float:left;
	height:16px;
	padding:0 16px 0 6px;
	background:#f5f5f5 url(chrome://diigotb/skin/toolbar-clip-bg.gif) no-repeat right 0;
	border:1px solid #ccc;
	border-bottom-width:0;
	font-family:"lucida grande",tahoma,verdana,arial,sans-serif;
	z-index:999;
	position:absolute;
}

div.diigoClipVideo.clipped {
  background-position: right -32px; left: 717px; top: 135px;
}

	div.diigoClipVideo span{
		font-weight:bold;
		font-size:10px;
		line-height:16px;
		text-decoration:underline;
		color:#03f;
		cursor:pointer;
		margin-right:6px
	}
	div.diigoClipVideo span:hover,div.diigoClipVideo span:active{
		color:#00f
	}
	/*.diigolet input{
		font-family:"lucida grande",tahoma,verdana,arial,sans-serif;
		font-size:9px;
	}*/
	
/*-----------notice msg--------------*/
.diigotb-notice-img  {
	float:left!important;
	height:16px!important;
	width:16px!important;
	margin-top:6px!important;
	margin-right:3px!important;
}
.success .diigotb-notice-img{
	background:url("chrome://diigotb/skin/notice-icons.png") no-repeat scroll 0 0 transparent!important;
}
.failed .diigotb-notice-img{
	background:url("chrome://diigotb/skin/notice-icons.png") no-repeat scroll -16px 0 transparent!important;
}
.info .diigotb-notice-img{
	background:url("chrome://diigotb/skin/notice-icons.png") no-repeat scroll -32px 0 transparent!important;
}
.process .diigotb-notice-img{
	background:url("chrome://diigotb/skin/processing.gif") no-repeat scroll left 0 transparent!important;
}	
	
.diigotb-notice-msg-rt  {
	background:url("chrome://diigotb/skin/notice-bar-2-bg-left.png") no-repeat scroll left bottom transparent!important;
	line-height:28px!important;
	padding-left:10px!important;
	height:30px!important;
}
.failed .diigotb-notice-msg-rt  {
	background:url("chrome://diigotb/skin/notice-bar-2-bg-left.png") no-repeat scroll left top transparent!important;
}
	
.diigotb-notice-close{
	float:right!important;
	height:16px!important;
	width:16px!important;
	margin-left:20px!important;
	margin-top:6px!important;
	cursor:pointer;
	background:url("chrome://diigotb/skin/notice-icons.png") no-repeat scroll -48px 0 transparent!important;
}

.diigotb-notice-close:hover{
	background-position: -63px 0!important;
}
	
.diigotb-notice-msg  {
	background:url("chrome://diigotb/skin/notice-bar-2-bg-right.png") no-repeat scroll right bottom transparent!important;
	float:right!important;
	height:30px!important;
	padding:0 11px 0 0!important;
	border: none!important;
	margin:0!important;
	position:fixed!important;
	font:12px/14px Helvetica,Arial,sans-serif!important;
	z-index:100000!important;
}
.diigotb-notice-msg a {
	color:#0044cc!important; 
	text-decoration:underline!important;
}
	
.failed.diigotb-notice-msg  {
	background:url("chrome://diigotb/skin/notice-bar-2-bg-right.png") no-repeat scroll right top transparent!important;
}
	
}


@media print{
em.diigoHighlight.a, em.diigoHighlight.b, em.diigoHighlight.c {
	border-bottom:0.5pt dashed Black;
}


/*image highlight*/
/*no inline comments*/
img.diigoHighlight {
	border:0.5pt dashed Black
}

/*float note*/
div.diigoHighlight.type_2 {
	display:none
}
div.diigoHighlight.type_2 span {
	display:none
}
}</style><style id="diigo-activeHighlight" type="text/css">dummyRuleForDigg{}</style></head>
<body link="#0000ff" vlink="#800080">
<p><!--Developing Embedded Software in C using ICC11/ICC12/Hiware by Jonathan W. Valvano
-->
<b><font face="Helvetica,Arial" size="4">Chapter 7:
Pointers</font></b></p>
<p><b><i><font face="Helvetica,Arial">What's in Chapter 7?</font></i></b></p>
<dir>
<p><a href="#ADDRESS">Definitions of address and pointer</a>
<font face="Monaco"><br>
</font><a href="#DECLARATIONS">Declarations of pointers define
the type and allocate space in memory</a>
<font face="Monaco"><br>
</font><a href="#REFERENCING">How do we use pointers</a><font face="Monaco"><br>
</font><a href="#MEMORY">Memory architecture of the TM4C123</a>
<font face="Monaco"><br>
</font><a href="#MATH">Pointer math</a><font face="Monaco"><br>
</font><a href="#COMPARE">Pointer comparisons</a><font face="Monaco"><br>
</font><a href="#FIFO">FIFO queue implemented with pointers</a>
<font face="Monaco"><br>
</font><a href="#IO">I/O port access</a>
</p>
</dir>
<p><font face="Times New Roman,Times">The ability to work with
memory addresses is an important
feature of the C language. This feature allows programmers the freedom
to perform operations similar to assembly language. Unfortunately,
along with the power comes the
potential danger of hard-to-find and serious run-time errors. In many
situations, array elements can be reached more efficiently through
pointers than by subscripting. It also allows pointers and pointer
chains to be used in data structures. Without pointers the run-time
dynamic memory allocation and deallocation using the heap would not be
possible. We will also use a format similar to pointers to develop
mechanisms for </font><a href="#IO">accessing I/O ports</a><font face="Times New Roman,Times">. These added degrees of
flexibility are absolutely essential for embedded systems.</font></p>
<p><b><i><font face="Helvetica,Arial"><a name="ADDRESS"></a>Addresses
and Pointers</font></i></b></p>
<p><font face="Times New Roman,Times">Addresses that can be
stored and changed are called <i>pointers</i>.
A pointer is really just a variable that contains an address. Although,
they can be used to reach objects in memory, their greatest advantage
lies in their ability to enter into arithmetic (and other) operations,
and to be changed. Just like other variables, pointers have a type. In
other words, the compiler knows the format (8-bit 16-bit 32-bit,
unsigned signed) of the data pointed to by the address.</font></p>
<p><font face="Times New Roman,Times">Not every address is a
pointer. For instance, we can write <b>&amp;var</b>
when we want the address of the variable <b>var</b>.
The result will be an address that is not a pointer since it does not
have a name or a place in memory. It cannot, therefore, have its value
altered.</font></p>
<p><font face="Times New Roman,Times">Other examples include
an array or a structure name. As we shall see in <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap8/chap8.htm">Chapter 8</a>,
an unsubscripted array name yields the address of the array. In <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap9/chap9.htm">Chapter 9</a>,
a structure name yields the address of the structure. But, since arrays
and structures cannot be moved around in memory, their addresses are
not variable. So, although, such addresses have a name, they do not
exist as objects in memory (the array does, but its address does not)
and cannot, therefore, be changed.</font></p>
<p><font face="Times New Roman,Times">A third example is a
character string. <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap3/chap3.htm">Chapter 3</a>
indicated that a character string yields the address of the character
array specified by the string. In this case the address has neither a
name or a place in memory, so it too is not a pointer.</font></p>
<p>&nbsp;</p>
<p><b><i><font face="Helvetica,Arial"><a name="DECLARATIONS"></a>Pointer
Declarations</font></i></b></p>
<p><font face="Times New Roman,Times">The syntax for declaring
pointers is like that for variables (<a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap4/chap4.htm">Chapter
4</a>)
except that pointers are distinguished by an asterisk that prefixes
their names. Listing 7-1 illustrates several legitimate pointer
declarations. Notice, in the third example, that we may mix pointers
and variables in a single declaration. I.e., the variable data and the
pointer pt3 are declared in the same statement. Also notice that the
data type of a pointer declaration specifies the type of object to
which the pointer refers, not the type of the pointer itself. As we
shall see, all pointers on the Cortex M contain 32-bit unsigned
absolute addresses.&nbsp;</font></p>
<dir>
<p><code>short
*pt1;&nbsp;&nbsp;/* define pt1, declare as
a pointer to a 16-bit integer */<br>
char *pt2;&nbsp;&nbsp;&nbsp;/* define pt2, declare as a
pointer to an 8-bit character */<br>
unsigned short data,*pt3;&nbsp;&nbsp;&nbsp;&nbsp;/*
define data and pt3, <br>
&nbsp;&nbsp;&nbsp;&nbsp;declare data as an unsigned
16-bit integer and <br>
&nbsp;&nbsp;&nbsp;&nbsp;declare pt3 as a pointer to a
16-bit unsigned integer */<br>
long *pt4;&nbsp;&nbsp;&nbsp;/* define pt4, declare as a
pointer to a 32-bit integer */<br>
extern short *pt5;&nbsp;&nbsp;&nbsp;&nbsp;/* declare
pt5 as a pointer to an integer */</code></p>
</dir>
<address><font face="Times New Roman,Times">Listing 7-1: Example
showing a pointer declarations</font></address>
<p>&nbsp;</p>
<p><font face="Times New Roman,Times">The best way to think of
the asterisk is to imagine that it stands for the phrase "object at" or
"object pointed to by." The first declaration in Listing 7-1 then reads
"the object at (pointed to by) <b>pt1</b>
is a 16-bit signed integer."</font></p>
<p><b><i><font face="Helvetica,Arial"><a name="REFERENCING"></a>Pointer
Referencing</font></i></b></p>
<p><font face="Times New Roman,Times">We can use the pointer
to retrieve data from memory or to store data into memory. Both
operations are classified as <i>pointer
references</i>. The syntax for using
pointers is like that for variables except that pointers are
distinguished by an asterisk that prefixes their names. Figures 7-1
through 7-4 illustrate several legitimate pointer references. In the
first figure, the global variables contain unknown data (actually we
know the compiler will zero global variables). The arrow
identifies the execution location. Assume addresses 0x20000000 through
0x20000017 exist in RAM.</font></p>
<p><code>long
*pt; &nbsp; &nbsp; &nbsp; // pointer to 32-bit data<br>
long data; &nbsp; &nbsp;&nbsp; // 32-bit<br>
long buffer[4]; // array of 4 32-bit numbers<br>
int main(void){<br>
&nbsp;&nbsp;pt = &amp;buffer[1];<br>
&nbsp;&nbsp;*pt = 1234;<br>
&nbsp;&nbsp;data = *pt;<br>
&nbsp;&nbsp;return 1;<br>
}<br>
<span style="text-decoration: underline;">address&nbsp;</span>&nbsp;&nbsp;
&nbsp; <span style="text-decoration: underline;">data</span>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;<span style="text-decoration: underline;">contents</span><br>
0x20000000&nbsp; &nbsp;0x00000000 &nbsp;&nbsp; pt<br>
0x20000004</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>data<br>
0x20000008</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[0]<br>
0x2000000C</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[1]<br>
0x20000010</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[2]<br>
0x20000014</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[3]<br>
</code><font style="font-style: italic;" face="Times New Roman,Times">Figure
7-1: Pointer
Referencing</font></p>
<p><font face="Times New Roman,Times">The C code <span style="font-family: Courier New; font-weight: bold;">pt=&amp;buffer[1];
</span>will set the </font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">pt
</span></font><font face="Times New Roman,Times">to point to&nbsp;</font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">buffer[1]</span></font><font face="Times New Roman,Times">. The expression <b>&amp;buffer[1]</b>
returns the address of the second 32-bit element of the <b>buffer</b>
(0x2000000C). Therefore the line <b>pt=&amp;buffer[1];</b>
makes <b>pt</b>
point to <b>buffer[1]</b>.</font></p>
<p><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;"></span></font><code><span style="text-decoration: underline;">address&nbsp;</span>&nbsp;&nbsp;
&nbsp; <span style="text-decoration: underline;">data</span>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;<span style="text-decoration: underline;">contents</span><br>
0x20000000&nbsp;&nbsp;</code><code>
<span style="font-weight: bold;">0x2000000C</span></code><code style="font-weight: bold;">&nbsp;</code><code><span style="font-weight: bold;">&nbsp;</span>&nbsp;
pt<br>
0x20000004</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>data<br>
0x20000008</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[0]<br>
0x2000000C</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[1]<br>
0x20000010</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[2]<br>
0x20000014</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[3]</code></p>
<p><font face="Times New Roman,Times">The C code <span style="font-family: Courier New; font-weight: bold;">(*pt)=0x1234;
</span>will
store <span style="font-weight: bold;">0x1234</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">
</span></font><font face="Times New Roman,Times">into the place pointed
to by&nbsp;</font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">pt</span></font><font face="Times New Roman,Times">. In particular, it
stores&nbsp;</font><font face="Times New Roman,Times"><span style="font-weight: bold;">0x1234</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">
</span></font><font face="Times New Roman,Times">into&nbsp;</font><font face="Times New Roman,Times">&nbsp;</font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">buffer[1]</span></font>.
When the <b>*pt</b>
occurs on the left-hand-side of an assignment statement data is stored
into memory at the address. Recall the <b>*pt</b>
means "the 32-bit signed integer at&nbsp;<font face="Times New Roman,Times">0x2000000C</font>".
I like to add the
parentheses () to clarify that <b>*</b>and
<b>pt</b>
are one object.&nbsp;Therefore the line <b>(*pt)=0x1234;</b>
sets <b>buffer[1]</b>
to 0x1234.</p>
<p><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;"></span></font><code><span style="text-decoration: underline;">address&nbsp;</span>&nbsp;&nbsp;
&nbsp; <span style="text-decoration: underline;">data</span>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;<span style="text-decoration: underline;">contents</span><br>
0x20000000&nbsp;&nbsp;</code><code>
0x2000000C</code><code style="font-weight: bold;">&nbsp;</code><code><span style="font-weight: bold;">&nbsp;&nbsp; </span>pt<br>
0x20000004</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>data<br>
0x20000008</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[0]<br>
0x2000000C</code><code>&nbsp;
&nbsp;<span style="font-weight: bold;">0x00001234</span>
&nbsp;&nbsp; </code><code>buffer[1]<br>
0x20000010</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[2]<br>
0x20000014</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[3]</code></p>
<p><font face="Times New Roman,Times">The C code <span style="font-family: Courier New; font-weight: bold;">data=</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">(*pt)</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">;
</span>will
read memory from address pointed to by pointer <span style="font-weight: bold;">pt</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">
</span></font><font face="Times New Roman,Times">into the place pointed
to by </font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">data</span></font><font face="Times New Roman,Times">. </font><font face="Times New Roman,Times">In particular, it
stores&nbsp;</font><font face="Times New Roman,Times"><span style="font-weight: bold;">0x1234</span></font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">
</span></font><font face="Times New Roman,Times">into&nbsp;</font><font face="Times New Roman,Times">&nbsp;</font><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;">data</span></font><font face="Times New Roman,Times">. </font><font face="Times New Roman,Times">When the <b>*pt</b>
occurs on the right-hand-side of an assignment statement data is
retrieved from memory at the address. Again, I like to add the
parentheses () to clarify that * and pt are one object. Therefore the
line <b>data=(*pt);</b>
sets <b>data</b>
to 0x1234 (more precisely, it copies the 32-bit information from <b>buffer[1]</b>
into <b>data</b>.)</font></p>
<p><font face="Times New Roman,Times"><span style="font-family: Courier New; font-weight: bold;"></span></font><code><span style="text-decoration: underline;">address&nbsp;</span>&nbsp;&nbsp;
&nbsp; <span style="text-decoration: underline;">data</span>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;<span style="text-decoration: underline;">contents</span><br>
0x20000000&nbsp;&nbsp;</code><code>
0x2000000C</code><code style="font-weight: bold;">&nbsp;</code><code><span style="font-weight: bold;">&nbsp;&nbsp; </span>pt<br>
0x20000004</code><code>&nbsp;
&nbsp;</code><code><span style="font-weight: bold;">0x00001234</span>
</code><code>&nbsp;&nbsp; </code><code>data<br>
0x20000008</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[0]<br>
0x2000000C</code><code>&nbsp;
&nbsp;0x00001234 &nbsp;&nbsp; </code><code>buffer[1]<br>
0x20000010</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[2]<br>
0x20000014</code><code>&nbsp;
&nbsp;0x00000000 &nbsp;&nbsp; </code><code>buffer[3]</code></p>
The following Cortex M
assembly was generated by Keil uVision when the above pointer
example was compiled.&nbsp;
<p class="MsoNormal"><span style="font-family: &quot;Courier New&quot;;"><br>
&nbsp;&nbsp;&nbsp;
48:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pt = &amp;buffer[1]; <br>
0x000003C4 4806&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[pc,#24]&nbsp; ; @0x000003E0<br>
0x000003C6 4907&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r1,[pc,#28]&nbsp; ; @0x000003E4<br>
0x000003C8 6008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[r1,#0x00]<br>
&nbsp;&nbsp;&nbsp;
49:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*pt = 1234; <br>
0x000003CA F24040D2&nbsp;
MOVW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,#0x4D2<br>
0x000003CE 6809&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r1,[r1,#0x00]<br>
0x000003D0 6008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[r1,#0x00]<br>
&nbsp;&nbsp;&nbsp;
50:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
data = *pt; <br>
0x000003D2 4804&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[pc,#16]&nbsp; ; @0x000003E4<br>
0x000003D4 6800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[r0,#0x00]<br>
0x000003D6 6800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[r0,#0x00]<br>
0x000003D8 4903&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
LDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r1,[pc,#12]&nbsp; ; @0x000003E8<br>
0x000003DA 6008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,[r1,#0x00]<br>
&nbsp;&nbsp;&nbsp;
51:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 1; <br>
0x000003DC 2001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MOVS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r0,#0x01<br>
&nbsp;&nbsp;&nbsp; 52: } <br>
0x000003DE 4770&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
lr</span><span style="font-family: &quot;Courier New&quot;;">&nbsp;
<br>
<br>
</span></p>
<p>&nbsp;</p>
<p><b><i><font face="Helvetica,Arial"><a name="MEMORY"></a>Memory
Addressing</font></i></b></p>
<p><font face="Times New Roman,Times">The size of a pointer
depends on the architecture of the CPU and the implementation of the C
compiler. For more information on the architectureof the TM4C see </font>Chapter
3 of <a href="http://users.ece.utexas.edu/%7Evalvano/arm/outline1.htm" target="_blank"><u>Embedded
Systems: Introduction to ARM Cortex M
Microcontrollers</u> </a>by
Jonathan W. Valvano.</p>
<dir>
<dir>
<p><img src="Chapter%207:%20Pointers%20--%20Valvano_files/reg.gif" height="150" width="372"></p>
</dir>
</dir>
<address><font face="Times New Roman,Times">Figure 7-2: Memory map
of the TM4C123 and TM4C1294. </font></address>
<p>&nbsp;</p>
<p><font face="Times New Roman,Times">Most embedded systems
employ a segmented memory architecture. From a physical standpoint we
might have a mixture of regular RAM, battery-backed-up RAM, regular
EEPROM, flash EPROM, regular PROM, one-time-programmable PROM and ROM.
RAM is the only memory structure that allows the program both read and
write access. Table
7-1 shows the various types of memory available on most microcomputers.
The RAM contains temporary information that is lost when
the power is shunt off. This means that all variables allocated in RAM
must be explicitly initialized at run time by the software. If the
embedded system includes a separate battery for the RAM, then
information is not lost when the main power is removed. Some
microcomputers have EEPROM. The number of erase/program cycles depends
on the memory technology. EEPROM is often used as the main program
memory during product development. In the final product we can use
EEPROM for configuration constants and even nonvolatile data logging.
</font><font face="Times New Roman,Times">The
one-time-programmable PROM is a simple nonvolatile storage used in
small volume products that can be programmed only once with inexpensive
equipment.<b> </b>The
ROM is a low-cost nonvolatile storage used in large volume products
that can be programmed only once at the factory. ***For the number of
write cycles available for ROM see the appropriate data sheet for that
microcontroller.<b>
</b></font></p>
<p>&nbsp;</p>
<p>
<table width="533" border="0" bordercolor="#808080" cellspacing="2">
  <tbody>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">Memory </font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">When
power is removed</font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">Ability
to Read/Write</font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">Program
cycles</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">RAM</font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">volatile</font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">random
and fast access</font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">infinite</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">battery-backed
RAM</font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">nonvolatile</font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">random
and fast access</font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">infinite</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">EEPROM</font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">nonvolatile
      </font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">easily
reprogrammed </font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">***</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">Flash </font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">nonvolatile
      </font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">easily
reprogrammed </font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">***</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">OTP PROM</font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">nonvolatile
      </font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">can be
easily programmed </font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">once</font></td>
    </tr>
    <tr>
      <td valign="top" width="23%"><font face="Times New Roman,Times" size="2">ROM</font></td>
      <td valign="top" width="25%"><font face="Times New Roman,Times" size="2">nonvolatile
      </font></td>
      <td valign="top" width="33%"><font face="Times New Roman,Times" size="2">programmed
at the factory</font></td>
      <td valign="top" width="19%"><font face="Times New Roman,Times" size="2">once</font></td>
    </tr>
  </tbody>
</table>
</p>
<address><font face="Times New Roman,Times">Table 7-1: Various types
of memory available for microntrollers. </font></address>
<p>&nbsp;</p>
<p><font face="Times New Roman,Times">In an embedded
application, we usually put global variables, the heap, and local
variables in RAM because these types of information can change during
execution. When software is to be executed on a regular computer, the
machine instructions are usually read from a mass storage device (like
a disk) and loaded into memory. Because the embedded system usually has
no mass storage device, the machine instructions and fixed constants
must be stored in nonvolatile memory. If there is both EEPROM and ROM
on our microcomputer, we put some fixed constants in EEPROM and some in
ROM. If it is information that we may wish to change in the future, we
could put it in EEPROM. Examples include language-specific strings,
calibration constants, finite state machines, and system ID numbers.
This allows us to make minor modifications to the system by
reprogramming the EEPROM without throwing the chip away. If our project
involves producing a small number of devices then the program can be
placed in EPROM or EEPROM. For a project with a large volume it will be
cost effective to place the machine instructions in ROM. </font></p>
<p>&nbsp;</p>
<p><b><i><font face="Helvetica,Arial"><a name="MATH"></a>Pointer
Arithmetic</font></i></b></p>
<p><font face="Times New Roman,Times">A major difference
between addresses and ordinary variables or constants has to do with
the interpretation of addresses. Since an address points to an object
of some particular type, adding one (for instance) to an address should
direct it to the next object, not necessarily the next byte. If the
address points to integers, then it should end up pointing to the next
integer. But, since integers occupy two bytes, adding one to an integer
address must actually increase the address by two. Likewise, if the
address points to long integers, then adding one to an address should
end up pointing to the next long integer by increasing the address by
four. A similar consideration applies to subtraction. In other words,
values added to or subtracted from an address must be scaled according
to the size of the objects being addressed. This automatic correction
saves the programmer a lot of thought and makes programs less complex
since the scaling need not be coded explicitly. The scaling factor for
long integers is four; the scaling factor for integers is two; the
scaling factor for characters is one. Therefore, character addresses do
not receive special handling. It should be obvious that when define
structures (see </font><a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap9/chap9.htm">Chapter 9</a><font face="Times New Roman,Times">) of other sizes, the
appropriate factors would have to be used.</font></p>
<p><font face="Times New Roman,Times">A related consideration
arises when we imagine the meaning of the difference of two addresses.
Such a result is interpreted as the number of objects between the two
addresses. If the objects are integers, the result must be divided by
two in order to yield a value which is consistent with this meaning.
See <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap8/chap8.htm">Chapter
8</a> for more on address arithmetic.</font></p>
<p><font face="Times New Roman,Times">When an address is
operated on, the result is always another address of the same type.
Thus, if <b>ptr</b>
is a signed 16-bit integer pointer, then <b>ptr+1</b>
is also points to a signed 16-bit integer. </font></p>
<p><font face="Times New Roman,Times">Precedence determines
the order of evaluation. <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap1/chap1.htm#PRECEDENCE">See a
table of
precedence.</a> One of the most
common mistakes results when the programmer meglects the fact the<b>
* </b>used as a unary pointer
reference has precedence over all binary operators. This means the
expression<b> *ptr+1</b>
is the same as <b>(*ptr)+1</b>
and not <b>*(ptr+1)</b>.
This is an important point so I'll mention it again,<i>
"When confused about precedence (and aren't we all) add parentheses to
clarify the expression."</i> </font></p>
<p>&nbsp;</p>
<p><b><i><font face="Helvetica,Arial"><a name="COMPARE"></a>Pointer
Comparisons</font></i></b></p>
<p><font face="Times New Roman,Times">One major difference
between pointers and other variables is that pointers are always
considered to be unsigned. This should be obvious since memory
addresses are not signed. This property of pointers (actually all
addresses) ensures that only unsigned operations will be performed on
them. It further means that the other operand in a binary operation
will also be regarded as unsigned (whether or not it actually is). In
the following example, <b>pt1</b>
and <b>pt2</b>[5]
return the current values of the addresses. For instance, if the array <b>pt2</b>[]
contains addresses, then it would make sense to write</font></p>
<p>&nbsp;</p>
<dir>
<p><code>short
*pt1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
define 16-bit integer pointer */<br>
short *pt2[10];&nbsp;&nbsp;/* define ten 16-bit integer
pointers */<b><br>
</b>short
done(void){&nbsp;&nbsp;/* returns true if pt1 is higher than
pt2[5] */<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(pt1&gt;pt2[5])
return(1); <br>
&nbsp;&nbsp;&nbsp;&nbsp;return(0);<br>
}</code></p>
</dir>
<address><font face="Times New Roman,Times">Listing 7-2: Example
showing a pointer comparisons</font></address>
<p>&nbsp;</p>
<p><font face="Times New Roman,Times">which performs an
unsigned comparison since pt1 and pt2 are pointers. Thus, if pt2[5]
contains 0x2000F000 and pt1 contains 0x20001000, the expression will
yield
true, since 0x2000F000 is a higher unsigned value than 0x20001000. </font></p>
<p><font face="Times New Roman,Times">It makes no sense to
compare a pointer to anything but another address or zero. C guarantees
that valid addresses can never be zero, so that particular value is
useful in representing the absence of an address in a pointer.</font></p>
<p><font face="Times New Roman,Times">Furthermore, to avoid
portability problems, only addresses within a single array should be
compared for relative value (e.g., which pointer is larger). To do
otherwise would necessarily involve assumptions about how the compiler
organizes memory. Comparisons for equality, however, need not observe
this restriction, since they make no assumption about the relative
positions of objects. For example if <b>pt1</b>
points into one data array and <b>pt2</b>
points into a different array, then comparing <b>pt1</b>
to <b>pt2</b>
would be meaningless. Which pointer is larger would depend on where in
memory the two arrays were assigned.</font></p>
<p><b><i><font face="Helvetica,Arial"><a name="FIFO"></a>A
FIFO Queue Example</font></i></b></p>
<p><font face="Times New Roman,Times">To illustrate the use of
pointers we will design a two-pointer FIFO. The first in first out
circular queue (FIFO) is also useful for data flow problems. It is a
very common data structure used for I/O interfacing. The order
preserving data structure temporarily saves data created by the source
(producer) before it is processed by the sink (consumer). The class of
FIFO’s studied in this section will be statically allocated
global structures. Because they are global variables, it means they
will exist permanently and can be shared by more than one program. The
advantage of using a FIFO structure for a data flow problem is that we
can decouple the source and sink processes. Without the FIFO we would
have to produce 1 piece of data, then process it, produce another piece
of data, then process it. With the FIFO, the source process can
continue to produce data without having to wait for the sink to finish
processing the previous data. This decoupling can significantly improve
system performance. </font></p>
<p><font face="Times New Roman,Times" size="2">GETPT</font><font face="Times New Roman,Times"> points to the data that
will be removed by the next call to GET, and </font><font face="Times New Roman,Times" size="2">PUTPT </font><font face="Times New Roman,Times">points to the empty
space where the data will stored by the next call to PUT. If the FIFO
is full when PUT is called then the subroutine should return a full
error (e.g., V=1.) Similarly, if the FIFO is empty when GET is called,
then the subroutine should return an empty error (e.g., V=1.) The </font><font face="Times New Roman,Times" size="2">PUTPT</font><font face="Times New Roman,Times"> and </font><font face="Times New Roman,Times" size="2">GETPT</font><font face="Times New Roman,Times"> must be wrapped back up
to the top when they reach the bottom. </font></p>
<p>&nbsp;</p>
<p><img src="Chapter%207:%20Pointers%20--%20Valvano_files/fifo.gif" height="161" width="361"></p>
<address><font face="Times New Roman,Times">Figure 7-3: Fifo example
showing the PUTPT and GETPT wrap. </font></address>
<p>&nbsp;</p>
<p><font face="Times New Roman,Times">There are two mechanisms
to determine whether the FIFO is empty or full. A simple method is to
implement a counter containing the number of bytes currently stored in
the FIFO. GET would decrement the counter and PUT would increment the
counter. The second method is to prevent the FIFO from being completely
full. For example, if the FIFO had 100 bytes allocated, then the PUT
subroutine would allow a maximum of 99 bytes to be stored. If there
were already 99 bytes in the FIFO and another PUT were called, then the
FIFO would not be modified and a full error would be returned. In this
way if PUTPT equals GETPT at the beginning of GET, then the FIFO is
empty. Similarly, if PUTPT+1 equals GETPT at the beginning of PUT, then
the FIFO is full. Be careful to wrap the PUTPT+1 before comparing it to
GETPT. This second method does not require the length to be stored or
calculated.</font></p>
<dir>
<p><code>/*
Pointer implementation of the FIFO */<br>
#define FifoSize 10 /* Number of 8 bit data in the Fifo */<br>
char *PUTPT;&nbsp;&nbsp;&nbsp;&nbsp;/* Pointer of where
to put next */<br>
char *GETPT;&nbsp;&nbsp;&nbsp;&nbsp;/* Pointer of where
to get next */<br>
/* FIFO is empty if PUTPT=GETPT */<br>
/* FIFO is full if PUTPT+1=GETPT */<br>
char Fifo[FifoSize]; /* The statically allocated fifo data */<br>
void InitFifo(void) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;PUTPT=GETPT=&amp;Fifo[0];
/* Empty when PUTPT=GETPT */<br>
}<br>
int PutFifo (char data) { char *Ppt; /* Temporary put pointer */</code><code><br>
&nbsp;&nbsp;&nbsp;&nbsp;Ppt=PUTPT; /* Copy of put
pointer */<br>
&nbsp;&nbsp;&nbsp;&nbsp;*(Ppt++)=data; /* Try to put
data into fifo */<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Ppt ==
&amp;Fifo[FifoSize]) Ppt = &amp;Fifo[0]; /* Wrap */<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (Ppt == GETPT ){ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);}&nbsp;&nbsp;&nbsp;/*
Failed, fifo was full */<br>
&nbsp;&nbsp;&nbsp;&nbsp;else{ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUTPT=Ppt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);&nbsp;&nbsp;&nbsp;/*
Successful */ <br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
int GetFifo (char *datapt) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (PUTPT== GETPT){ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);}&nbsp;&nbsp;&nbsp;/*
Empty if PUTPT=GETPT */<br>
&nbsp;&nbsp;&nbsp;&nbsp;else{ </code><code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*datapt=*(GETPT++);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(GETPT == &amp;Fifo[FifoSize])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GETPT
= &amp;Fifo[0];</code><code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}</code></p>
</dir>
<address><font face="Times New Roman,Times">Listing 7-3: Fifo queue
implemented with pointers</font></address>
<p><font face="Times New Roman,Times">Since these routines
have read modify write accesses to global variables the three functions
(InitFifo, PutFifo, GetFifo) are themselves not reentrant. Consequently
interrupts are temporarily disabled, to prevent one thread from
reentering these Fifo functions. One advantage of this pointer
implementation is that if you have a single thread that calls the
GetFifo (e.g., the main program) and a single thread that calls the
PutFifo (e.g., the serial port receive interrupt handler), then this
PutFifo function can interrupt this GetFifo function without loss of
data. So in this particular situation, interrupts would not have to be
disabled. It would also operate properly if there were a single
interrupt thread calling GetFifo (e.g., the serial port transmit
interrupt handler) and a single thread calling PutFifo (e.g., the main
program.) On the other hand, if the situation is more general, and
multiple threads could call PutFifo or multiple threads could call
GetFifo, then the interrupts would have to be temporarily disabled.</font></p>
<p><b><i><font face="Helvetica,Arial"><a name="IO"></a>I/O
Port Access</font></i></b></p>
<p><font face="Times New Roman,Times">Even though the
mechanism to access I/O ports technically does not fit the definition
of pointer, it is included in this chapter because it involves
addresses. The line </font><code><span style="font-family: Courier;">NVIC_ST_RELOAD_R
=
delay-1; </span></code><font face="Times New Roman,Times">generates a
32-bit I/O
write operation to the port at address 0xE000E014. The </font><code>GPIO_PORTF_DATA_R&nbsp;</code><font face="Times New Roman,Times">on the right side of an
assignment statement generates a 32-bit read from address 0x400253FC.
The&nbsp;</font><code><span style="font-family: Courier;">NVIC_ST_CTRL_R</span></code><font face="Times New Roman,Times"> in the while loop
generates a 32-bit I/O
read operation from the port at address 0xE000E010.&nbsp;</font></p>
<dir>
<p><code>#define
NVIC_ST_CTRL_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(*((volatile unsigned long *)0xE000E010))<br>
#define
NVIC_ST_RELOAD_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(*((volatile </code><code>unsigned
long </code><code>*)0xE000E014))<br>
#define
NVIC_ST_CURRENT_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(*((volatile&nbsp;</code><code>unsigned
long </code><code>*)0xE000E018))<br>
#define
GPIO_PORTF_DATA_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(*((volatile unsigned long *)0x400253FC))</code><code><br>
<span style="font-family: Courier;">//
The delay parameter is in units of the 80 MHz core clock. (12.5 ns)<br>
void SysTick_Wait(</span></code><code>unsigned
long </code><code><span style="font-family: Courier;"> delay){
unsigned long
data;<br>
&nbsp; NVIC_ST_RELOAD_R = delay-1;&nbsp; // number of counts to
wait<br>
&nbsp; NVIC_ST_CURRENT_R =
0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // any
value written to CURRENT clears<br>
&nbsp; data = </span></code><code>GPIO_PORTF_DATA_R;</code><br>
<code><span style="font-family: Courier;">&nbsp;
while((NVIC_ST_CTRL_R&amp;0x00010000)==0){ // wait for count flag<br>
&nbsp; }<br>
} <br>
</span></code></p>
</dir>
<p><i>Listing
7-5: Sample Program that accesses I/O ports</i></p>
<p></p>
<p class="MsoBodyText">To
understand the port definitions in C, we remember <b style=""><span style="font-family: &quot;Courier New&quot;;">#define</span></b>
is simply a copy
paste. E.g.,<o:p></o:p></p>
<p class="MsoBodyText"><b style=""><span style="font-family: &quot;Courier New&quot;;"><span style="">&nbsp;&nbsp;&nbsp; </span>#define
PA5&nbsp;&nbsp; (*((volatile unsigned long *)0x40004080))<br>
</span></b><b style=""><span style="font-family: &quot;Courier New&quot;;"><span style="">&nbsp;&nbsp;&nbsp; </span></span></b><b style=""><span style="font-family: &quot;Courier New&quot;;">data = PA5;<o:p></o:p></span></b></p>
<p class="MsoBodyText">becomes<o:p></o:p></p>
<p class="MsoBodyText"><b style=""><span style="font-family: &quot;Courier New&quot;;"><span style="">&nbsp;&nbsp;&nbsp; </span>data
= </span></b><b style=""><span style="font-family: &quot;Courier New&quot;;">(*((volatile&nbsp;</span></b><b style=""><span style="font-family: &quot;Courier New&quot;;">unsigned long</span></b><b style=""><span style="font-family: &quot;Courier New&quot;;"> *)0x40004080))</span></b><b style=""><span style="font-family: &quot;Courier New&quot;;">;<o:p></o:p></span></b></p>
<p class="MsoBodyText">To
understand why we define ports this way, let’s break
this port definition into pieces. First, 0x40004080 is the address of
Port A
bit 5. If we write just <b style=""><span style="font-family: &quot;Courier New&quot;;">#define</span></b>
<b style=""><span style="font-family: &quot;Courier New&quot;;">PA5</span></b>
<b style=""><span style="font-family: &quot;Courier New&quot;;">0x40004080</span></b>
it will create<o:p></o:p></p>
<p class="MsoBodyText"><b style=""><span style="font-family: &quot;Courier New&quot;;"><span style="">&nbsp;&nbsp;&nbsp; </span>data
= 0x40004080;<o:p></o:p></span></b></p>
<p class="MsoBodyText">which
does not read the contents of PA5 as desired. This
means we need to dereference the address. If we write <b style=""><span style="font-family: &quot;Courier New&quot;;">#define</span></b>
<b style=""><span style="font-family: &quot;Courier New&quot;;">PA5</span></b>
<b style=""><span style="font-family: &quot;Courier New&quot;;">(*0x40004080)</span></b>
it will create<o:p></o:p></p>
<p class="MsoBodyText"><b style=""><span style="font-family: &quot;Courier New&quot;;"><span style="">&nbsp;&nbsp;&nbsp; </span>data
= (*0x40004080);<o:p></o:p></span></b></p>
<p class="MsoBodyText">This
will attempt to read the
contents at 0x40004080, but doesn’t know whether to read 8,
16, or 32 bits. So
the compiler gives a syntax error because the type of data does not
match the
type of (*0x40004080). <span style="">&nbsp;</span>To
solve a type
mismatch in C we <b style="">typecast</b>,
placing a
(new type) in front of the object we wish to convert. We wish force the
type
conversion to unsigned 32 bits, so we modify the definition to include
the
typecast.&nbsp;<b style=""><span style="font-family: &quot;Courier New&quot;;"><span style=""></span></span></b><b style=""><span style="font-family: &quot;Courier New&quot;;"></span></b><o:p></o:p></p>
<span style="font-size: 11pt; font-family: &quot;Book Antiqua&quot;,serif;">The
</span><b style=""><span style="font-size: 11pt; font-family: &quot;Courier New&quot;;">volatile</span></b><span style="font-size: 11pt; font-family: &quot;Book Antiqua&quot;,serif;"><span style="">&nbsp;</span>is
added because the value of a port can
change beyond the direct action of the software. It forces the C
compiler to
read a new value each time through a loop and not rely on the previous
value. <span style="">&nbsp;</span></span>
<dir>
<p><code></code><code><span style="font-family: Courier;">#define
PA5&nbsp;&nbsp; (*((volatile unsigned long *)0x40004080))<br>
void wait(void){<br>
&nbsp; while((PA5&amp;0x20)==0){};<br>
}<br>
void wait2(void){<br>
&nbsp; while(((*((volatile unsigned long
*)0x40004080))&amp;0x20)==0){};<br>
}<br>
void wait3(void){<br>
&nbsp; volatile unsigned long *pt;<br>
&nbsp; pt = ((volatile unsigned long *)0x40004080);<br>
&nbsp; while(((*pt)&amp;0x20)==0){};<br>
}</span></code></p>
</dir>
<p><i>Listing
7-6:&nbsp; Program that accesses I/O ports using pointers</i></p>
<p><font face="Times New Roman,Times">The function </font><code><span style="font-family: Courier;">wait3 </span></code><font face="Times New Roman,Times">first sets
the&nbsp;I/O pointer then accesses the I/O port indirectly
through
the pointer.</font></p>
<p></p>
<p><font face="Times New Roman,Times">Go to <a href="http://users.ece.utexas.edu/%7Evalvano/embed/chap8/chap8.htm">Chapter 8 on Arrays and
Strings</a> Return to <a href="http://users.ece.utexas.edu/%7Evalvano/embed/index.html">Table of Contents</a>
</font></p>
<p>&nbsp;</p>


</body></html>